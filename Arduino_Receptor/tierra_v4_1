// ESTACIÓN TIERRA
// Python <===> Estación de Tierra

#include <SoftwareSerial.h>
#include <stdint.h>

#define LED_PIN      13   // LED de actividad (verde)
#define LED_ERROR    12   // LED rojo de error
#define LED_CHKERR    8   // Error Checksum
#define BAUDRATE   9600

// Protocolo binario (igual que en el satélite)
#define STX         0xAA
#define TYPE_CMD    0x01
#define TYPE_DATA   0x10
#define TYPE_STATUS 0x11

SoftwareSerial mySerial(10, 11);  // RX, TX con Satélite


// =========================
// Funciones para el checksum (texto) – ya no se usan con el satélite,
// pero las dejo por compatibilidad si algún día quieres reaprovecharlas.
// =========================

// Suma simple de todos los caracteres del String (0-255)
uint8_t calcularChecksum(const String &s) {
  uint8_t sum = 0;
  for (unsigned int i = 0; i < s.length(); i++) {
    sum += (uint8_t)s[i];
  }
  return sum;
}

// Devuelve true si checksum OK.
// Deja en 'frame' solo "datos" (sin "*cs").
// En caso de error, enciende LED_CHKERR.
bool verificarYQuitarChecksum(String &frame) {
  int pos = frame.indexOf('*');

  if (pos < 0) {
    // No hay checksum -> error
    digitalWrite(LED_CHKERR, HIGH);
    return false;
  }

  String data  = frame.substring(0, pos);
  String csStr = frame.substring(pos + 1);
  csStr.trim();
  if (csStr.length() == 0){
    digitalWrite(LED_CHKERR, HIGH);
    return false;
  }

  int csRecv = csStr.toInt();  // checksum recibido en DECIMAL
  if (csRecv < 0 || csRecv > 255){
    digitalWrite(LED_CHKERR, HIGH);
    return false;
  }

  uint8_t csCalc = calcularChecksum(data);
  if (csCalc != (uint8_t)csRecv) {
    digitalWrite(LED_CHKERR, HIGH);
    return false;
  }

  // Checksum OK
  frame = data;                       // nos quedamos solo con el cuerpo "x:..."
  digitalWrite(LED_CHKERR, LOW);
  return true;
}


// =========================
// Protocolo binario (Tierra <-> Satélite)
// =========================

uint8_t calcChecksumBin(uint8_t type, uint8_t len, const uint8_t *payload) {
  uint16_t sum = type + len;
  for (uint8_t i = 0; i < len; i++) {
    sum += payload[i];
  }
  return (uint8_t)sum;
}

void sendFrame(uint8_t type, const uint8_t *payload, uint8_t len) {
  uint8_t cs = calcChecksumBin(type, len, payload);
  mySerial.write((uint8_t)STX);  // 0xAA
  mySerial.write(type);
  mySerial.write(len);
  if (len > 0 && payload != NULL) {
    mySerial.write(payload, len);
  }
  mySerial.write(cs);
}



// Buffer de recepción binaria desde el Satélite
static uint8_t rxState  = 0;
static uint8_t rxType   = 0;
static uint8_t rxLen    = 0;
static uint8_t rxBuf[16];
static uint8_t rxIndex  = 0;


// =========================
// Setup
// =========================

void setup() {

  Serial.begin(BAUDRATE);   // USB <--> Python
  mySerial.begin(BAUDRATE); // Enlace con Satélite

  pinMode(LED_PIN, OUTPUT);
  pinMode(LED_ERROR, OUTPUT);
  pinMode(LED_CHKERR, OUTPUT);
  digitalWrite(LED_PIN, LOW);
  digitalWrite(LED_ERROR, LOW);
  digitalWrite(LED_CHKERR, LOW);

  Serial.setTimeout(50);
  mySerial.setTimeout(50);

  Serial.println(F("Estación de tierra lista. Esperando comandos desde Python."));
}


void loop() {


  // Lectura de datos desde el Satélite (BINARIO)
  // y reenvío a Python en TEXTO.


  while (mySerial.available()) {
    uint8_t b = (uint8_t)mySerial.read();

    switch (rxState) {
      case 0:  // esperando STX
        if (b == STX) {
          rxState = 1;
        }
        break;

      case 1:  // TYPE
        rxType = b;
        rxState = 2;
        break;

      case 2:  // LEN
        rxLen = b;
        if (rxLen > sizeof(rxBuf)) {
          // overflow: error de trama
          //digitalWrite(LED_CHKERR, HIGH);
          digitalWrite(LED_ERROR, HIGH);
          rxState = 0;
        } else {
          rxIndex = 0;
          rxState = (rxLen == 0) ? 4 : 3;
        }
        break;

      case 3:  // PAYLOAD
        rxBuf[rxIndex++] = b;
        if (rxIndex >= rxLen) {
          rxState = 4;
        }
        break;

      case 4: { // CHECKSUM
        uint8_t csRecv = b;
        uint8_t csCalc = calcChecksumBin(rxType, rxLen, rxBuf);

        if (csRecv != csCalc) {
          // Checksum incorrecto: encendemos LED_CHKERR y LED_ERROR
          digitalWrite(LED_CHKERR, HIGH);
          //digitalWrite(LED_ERROR, HIGH);
          // Aviso mínimo a Python
          Serial.print(F("CHKERR|"));
          rxState = 0;
          break;
        }

        // Checksum OK
        digitalWrite(LED_CHKERR, LOW);

        bool errorFrame = false;

        if (rxType == TYPE_DATA) {
          // rxBuf[0] = id_dato (int8)
          int8_t id = (int8_t)rxBuf[0];

          if (rxLen == 1) {
            // Solo id (errores: -2, -3, -5, -6)
            // Enviamos "-2|", "-3|", etc. a Python
            Serial.print(id);
            Serial.print('|');
            errorFrame = true;  // cualquier id negativo es error
          }
          else if (rxLen == 5) {
            // id + float (humedad, temperatura, media, distancia)
            union {
              float f;
              uint8_t b[4];
            } u;
            u.b[0] = rxBuf[1];
            u.b[1] = rxBuf[2];
            u.b[2] = rxBuf[3];
            u.b[3] = rxBuf[4];

            float valor = u.f;

            // reenviamos como "id:valor|"
            Serial.print(id);
            Serial.print(':');
            // De momento sin forzar decimales (Python lo parsea igual).
            Serial.print(valor);
            Serial.print('|');

            if (id < 0) {
              errorFrame = true;
            }
          }
          else if (rxLen == 2) {
            // id + byte (p.ej. id=6 y ángulo 0–180)
            int8_t id2 = (int8_t)rxBuf[0];
            int8_t v   = (int8_t)rxBuf[1];

            Serial.print(id2);
            Serial.print(':');
            Serial.print(v);
            Serial.print('|');

            if (id2 < 0) {
              errorFrame = true;
            }
          }
        }
        else if (rxType == TYPE_STATUS) {
          // Códigos 100..403
          if (rxLen == 2) {
            uint16_t code = (uint16_t)(rxBuf[0] | (rxBuf[1] << 8));

            // Reenviamos como "1:code|" (mismo formato lógico de antes)
            Serial.print(F("1:"));
            Serial.print(code);
            Serial.print('|');

            // Código de error de checksum en el satélite: 190
            if (code == 190) {
              errorFrame = true;
              // LED_CHKERR lo reservamos para errores locales de enlace,
              // como ya hacías (la línea estaba comentada).
            }
          }
        }

        // Gestión LED_ERROR según si es error (sensores/servo/estado CHKERR remoto)
        if (errorFrame) {
          digitalWrite(LED_ERROR, HIGH);
        } else {
          digitalWrite(LED_ERROR, LOW);
        }

        rxState = 0;
        break;
      }
    }
  }

  // =====================================================
  // 2) Estación Tierra <--> Python (TEXTO)
  //    Comandos desde Python hacia el Satélite (BINARIO).
  // =====================================================

  String com = "";

  while (Serial.available()) {
    // Leemos el último comando completo recibido desde Python (hasta '|')
    com = Serial.readStringUntil('|');
  }

  if (com.length() == 0) {
    // No hay comando nuevo desde Python
    return;
  }

  // 'com' es el cuerpo, por ejemplo:
  // "0:1:0", "1:3:2000", "2:1:-30", "3:3:1000", etc.

  int grupo  = 0;
  int codigo = 0;
  long valor1 = 0;

  int p1 = com.indexOf(':');
  int p2 = -1;

  if (p1 >= 0) {
    p2 = com.indexOf(':', p1 + 1);
  }

  if (p1 < 0) {
    // Formato inesperado -> ignoramos
    return;
  }

  grupo = com.substring(0, p1).toInt();

  if (p2 < 0) {
    // Formato "g:c"
    codigo = com.substring(p1 + 1).toInt();
    valor1 = 0;
  } else {
    // Formato "g:c:v"
    codigo = com.substring(p1 + 1, p2).toInt();
    if (p2 + 1 < (int)com.length()) {
      valor1 = com.substring(p2 + 1).toInt();
    } else {
      valor1 = 0;
    }
  }

  // Construimos payload binario para TYPE_CMD
  uint8_t payload[4];
  payload[0] = (uint8_t)grupo;
  payload[1] = (uint8_t)codigo;

  int16_t v = (int16_t)valor1;
  payload[2] = (uint8_t)(v & 0xFF);
  payload[3] = (uint8_t)(v >> 8);

  // Enviar comando al Satélite en binario
  sendFrame(TYPE_CMD, payload, 4);

  // Gestión del LED de actividad en Tierra
  // 0:1:0  -> START global
  // 0:2:0  -> STOP global
  if (com == "0:1:0") {
    digitalWrite(LED_PIN, HIGH);
  }
  else if (com == "0:2:0") {
    digitalWrite(LED_PIN, LOW);
  }

  // aquí se puede añadir más lógica local
  // según otros comandos (p.ej. encender/apagar LED
  // con el estado de DHT o del servo, etc.).
}
