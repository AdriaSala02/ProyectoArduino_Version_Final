// SATÉLITE
// Satélite <===> Estación de Tierra

#include <SoftwareSerial.h>
#include <DHT.h>
#include <Servo.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdint.h>

// Pines
#define DHTPIN   2
#define DHTTYPE  DHT11
#define TRIG_PIN 7
#define ECHO_PIN 8
#define SERVO_PIN 4
#define LED_PIN 13
#define LED_E 12
#define LED_ERR_Dist 9
#define LED_CHK_ERR_S 3

// Protocolo binario
#define STX         0xAA
#define TYPE_CMD    0x01
#define TYPE_DATA   0x10
#define TYPE_STATUS 0x11

SoftwareSerial mySerial(10, 11);  // RX, TX con Arduino Tierra
Servo servoMotor;
DHT dht(DHTPIN, DHTTYPE);

// VARIABLES

  int i = 0;

  // Periodos GLOBALES
  unsigned long periodoGlobalEnvio = 1000;   // ms. 0 = sin límite global
  unsigned long ultimoEnvioGlobal  = 0;      // último envío de *cualquier* dato

  // Sensor de distancia
  const float MIN_CM = 3.0;
  const float MAX_CM = 700.0;
  const unsigned long TIMEOUT_DIST = 30000;

  const int NUM_MEDIDAS = 3;
  bool enviarDistancia = true;
  unsigned long periodoDistancia = 1000;    // ms
  unsigned long ultimoEnvioDist  = 0;

  // SERVO
  const int PASO_SERVO = 2;
  const unsigned long INTERVALO_SERVO = 20;
  unsigned long tUltimoServo = 0;
  int angulo = 0;
  int direccion = 1;
  unsigned long tiempoCicloServo = 3000;   // ms que tarda en hacer 180º

  // Control del envío de datos del servo
  unsigned long periodoServoDatos     = 1000;   // ms telemetría servo
  unsigned long ultimoEnvioServoDatos = 0;
  bool enviarServoDatos               = false;  // telemetría desactivada por defecto

  // Modos del servo
  bool modoManual              = false;
  int  anguloObjetivo          = 0;
  unsigned long inicioManual   = 0;
  const unsigned long TIEMPO_MANTENER_ANG = 4000;
  bool servoMovimientoActivo   = true;    // controla el barrido automático

  // DHT
  bool enviarDatosDHT          = true;
  unsigned long periodoDHT     = 1000;   // en ms
  unsigned long ultimoEnvioDHT = 0;

  // Para la media
  bool  calcularMediaEnSatelite = true;  // true = la media se calcula y envía desde el satélite
  float bufferTemps[10];
  int   indiceTemp = 0;
  int   numTemp    = 0;
  float mediaTemp  = 0.0;

  // Buffers para comunicación (texto, ya no usados)
  static char ultimo_comando[64] = "";
  static char frameBuf[64];
  static uint8_t frameIndex = 0;
  unsigned long ultimoErrorChk = 0;
  const unsigned long DURACION_LED_CHK = 200;

  // Estado de recepción binaria
  static uint8_t rxState = 0;
  static uint8_t rxType  = 0;
  static uint8_t rxLen   = 0;
  static uint8_t rxBuf[16];
  static uint8_t rxIndex = 0;

// =========================
// PROTOTIPOS
// =========================

uint8_t calcularChecksum(const char *s);
void enviarConChecksum(const char *cuerpo);
bool verificarYExtraercuerpo(const char *frame, char *dataOut, size_t outSize);
void decodificarComando(const char *s, int &grupo, int &codigo, long &valor1, long &valor2);
void enviarCodigoMensaje(uint16_t code);

long  medirPulso();
float medirDistanciaMedia(int n);
float calcularMedia();
bool  puedeEnviarGlobal();
void  trim(char *s);

// Protocolo binario
uint8_t calcChecksum(uint8_t type, uint8_t len, const uint8_t *payload);
void sendFrame(uint8_t type, const uint8_t *payload, uint8_t len);
void enviarDatoFloat(int8_t id, float valor);
void enviarDatoByte(int8_t id, int8_t valor);
void enviarError(int8_t idError);
void procesarFrameComando(uint8_t *payload, uint8_t len, unsigned long ahora);

// ==========================================================
// Funciones auxiliares
// ==========================================================

// hace lo mismo que el trim para strings: quita espacios y saltos de línea al inicio y final
void trim(char *s) {
  // Trim inicio
  char *p = s;
  while (*p == ' ' || *p == '\r' || *p == '\n' || *p == '\t') {
    p++;
  }
  if (p != s) {
    memmove(s, p, strlen(p) + 1);
  }

  // Trim final
  int len = strlen(s);
  while (len > 0 &&
         (s[len - 1] == ' ' || s[len - 1] == '\r' || s[len - 1] == '\n' || s[len - 1] == '\t')) {
    s[len - 1] = '\0';
    len--;
  }
}

// =========================
// Checksum y envío (texto - ya no usado)
// =========================

uint8_t calcularChecksum(const char *s) {
  uint8_t sum = 0;
  while (*s) {
    sum += (uint8_t)(*s);
    s++;
  }
  return sum;
}

void enviarConChecksum(const char *cuerpo) {
  uint8_t cs = calcularChecksum(cuerpo);
  mySerial.print(cuerpo);
  mySerial.print('*');  // marca para que pare
  mySerial.print(cs);   // en decimal
  mySerial.print('|');
}

// frame = "datos*cs" o "datos" (sin '|').
// Devuelve true si checksum ok o no hay checksum.
// dataOut queda solo con "datos" (sin "*cs").
bool verificarYExtraercuerpo(const char *frame, char *dataOut, size_t outSize) {
  const char *asterisk = strchr(frame, '*');    // guarda la posición del asterisco, o sea del checksum

  if (asterisk == NULL) {
    digitalWrite(LED_CHK_ERR_S, HIGH);
    ultimoErrorChk = millis();
    return false;
  }

  size_t dataLen = (size_t)(asterisk - frame);
  if (dataLen == 0 || dataLen >= outSize) {
    digitalWrite(LED_CHK_ERR_S, HIGH);
    ultimoErrorChk = millis();
    return false;
  }

  char data[64];
  memcpy(data, frame, dataLen);
  data[dataLen] = '\0';

  const char *csStr = asterisk + 1;
  if (*csStr == '\0'){
    digitalWrite(LED_CHK_ERR_S, HIGH);
    ultimoErrorChk = millis();
    return false;
  }
  int csRecv = atoi(csStr);
  if (csRecv < 0 || csRecv > 255) return false;

  uint8_t csCalc = calcularChecksum(data);
  if (csCalc != (uint8_t)csRecv) {
    digitalWrite(LED_CHK_ERR_S, HIGH);
    ultimoErrorChk = millis();
    return false;
  }

  // CHECKSUM okei
  strncpy(dataOut, data, outSize - 1);
  dataOut[outSize - 1] = '\0';
  digitalWrite(LED_CHK_ERR_S, LOW);
  return true;
}

// decodifica "16:1:3:20" en 4 campos separados por ":".
void decodificarComando(const char *s, int &grupo, int &codigo, long &valor1, long &valor2){
  grupo  = -1;
  codigo = -1;
  valor1 = 0;
  valor2 = 0;

  char buf[32];
  strncpy(buf, s, sizeof(buf) - 1);   // NO usamos lo del buffer original por seguridad, lo copiamos y trabajamos con la copia
  buf[sizeof(buf) - 1] = '\0';

  char *ubi_parte;
  char *parte = strtok_r(buf, ":", &ubi_parte);   // copiamos y editamos lo que haya en buffer editable
  if (parte != NULL) {
    grupo = atoi(parte);
  }

  parte = strtok_r(NULL, ":", &ubi_parte);
  if (parte != NULL) {
    codigo = atoi(parte);
  }

  parte = strtok_r(NULL, ":", &ubi_parte);
  if (parte != NULL) {
    valor1 = atol(parte);
  }

  parte = strtok_r(NULL, ":", &ubi_parte);
  if (parte != NULL) {
    valor2 = atol(parte);
  }
}

// =========================
// Protocolo binario
// =========================

uint8_t calcChecksum(uint8_t type, uint8_t len, const uint8_t *payload) {
  uint16_t sum = type + len;
  for (uint8_t i = 0; i < len; i++) {
    sum += payload[i];
  }
  return (uint8_t)sum;
}

void sendFrame(uint8_t type, const uint8_t *payload, uint8_t len) {
  uint8_t cs = calcChecksum(type, len, payload);
  mySerial.write((uint8_t)STX);
  mySerial.write(type);
  mySerial.write(len);
  if (len > 0 && payload != NULL) {
    mySerial.write(payload, len);
  }

  // PRUEBA: checksum CORRECTO (comportamiento normal)
  mySerial.write(cs);

  // PRUEBA checksum MALO a propósito
  //mySerial.write((uint8_t)(cs + 1));   // <-- ERROR INTENCIONAL
}


// Enviar código de mensaje de estado: TYPE_STATUS + code (100..403)
void enviarCodigoMensaje(uint16_t code) {
  uint8_t payload[2];
  payload[0] = (uint8_t)(code & 0xFF);
  payload[1] = (uint8_t)(code >> 8);
  sendFrame(TYPE_STATUS, payload, 2);
}

// Enviar dato float (id: 2,3,4,5)
void enviarDatoFloat(int8_t id, float valor) {
  union {
    float f;
    uint8_t b[4];
  } u;
  u.f = valor;

  uint8_t payload[1 + 4];
  payload[0] = (uint8_t)id;    // se interpretará como int8_t en Tierra
  payload[1] = u.b[0];
  payload[2] = u.b[1];
  payload[3] = u.b[2];
  payload[4] = u.b[3];

  sendFrame(TYPE_DATA, payload, sizeof(payload));
}

// Enviar dato byte (id: 6 ángulo, o similares)
void enviarDatoByte(int8_t id, int8_t valor) {
  uint8_t payload[2];
  payload[0] = (uint8_t)id;
  payload[1] = (uint8_t)valor;
  sendFrame(TYPE_DATA, payload, sizeof(payload));
}

// Enviar solo un código de error (id negativo: -2, -3, -5, -6)
void enviarError(int8_t idError) {
  uint8_t payload[1];
  payload[0] = (uint8_t)idError;   // -2, -3, -5, -6
  sendFrame(TYPE_DATA, payload, 1);
}

// =========================
// Medidas y tiempos
// =========================

long medirPulso() {
  digitalWrite(TRIG_PIN, LOW);
  delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH);
  delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  return pulseIn(ECHO_PIN, HIGH, TIMEOUT_DIST);
}

float medirDistanciaMedia(int n) {
  float v[10]; // entran hasta 10 medidas
  int medidas_validas = 0;
 
  if (n > 10) {
    n = 10;
  }

  for (int i = 0; i < n; i++) {
    long duracion = medirPulso();

    if (duracion == 0) { // por si no ha habido eco
      continue;
    }
    float d = duracion * 0.0343f / 2.0f;

    if ((d < MIN_CM) || (d > MAX_CM)) {
      Serial.println(F("fuera de rango"));
      continue;
    }

    v[medidas_validas] = d;
    medidas_validas++;

    delayMicroseconds(300);
  }

  if (medidas_validas == 0)
    return -1.0f;   // error

  // Ordenación con método burbuja
  for (int i = 0; i < medidas_validas - 1; i++) {
    for (int j = 0; j < medidas_validas - 1 - i; j++) {
      if (v[j] > v[j + 1]) {
        float dist_temporal = v[j];
        v[j] = v[j + 1];
        v[j + 1] = dist_temporal;
      }
    }
  }

  return v[medidas_validas / 2]; // mediana
}

float calcularMedia() {
  if (numTemp == 0) return 0.0f;
  float suma = 0.0f;
  for (int i = 0; i < numTemp; i++) suma += bufferTemps[i];
  return suma / (float)numTemp;
}

// Devuelve true si ya ha pasado el periodo global entre envíos.
// Si periodoGlobalEnvio == 0, no hay límite global.
bool puedeEnviarGlobal() {
  if (periodoGlobalEnvio == 0) {
    return true;
  }
  unsigned long ahora = millis();
  if (ahora - ultimoEnvioGlobal >= periodoGlobalEnvio) {
    ultimoEnvioGlobal = ahora;  // actualizamos el último envío global
    return true;
  }
  return false;
}

// =========================
// Procesar comandos binarios
// =========================

void procesarFrameComando(uint8_t *payload, uint8_t len, unsigned long ahora) {
  if (len < 2) return;

  int grupo  = payload[0];
  int codigo = payload[1];
  long valor1 = 0;
  long valor2 = 0;  // ya no lo usamos, pero lo dejamos por compatibilidad mental :)

  if (len >= 4) {
    int16_t v = (int16_t)(payload[2] | (payload[3] << 8));
    valor1 = (long)v;
  }

  // DEBUG para comprobar que llegan comandos
  Serial.print(F("Comando recibido: grupo="));
  Serial.print(grupo);
  Serial.print(F(" codigo="));
  Serial.print(codigo);
  Serial.print(F(" v1="));
  Serial.println(valor1);

  // ======================================================
  // Grupo 0: General (0:...)
  // ======================================================
  if (grupo == 0) {

    // 0:1:0| --> empezar global
    if (codigo == 1) {
      enviarDatosDHT        = true;
      enviarDistancia       = true;
      enviarServoDatos      = true;
      servoMovimientoActivo = true;
      enviarCodigoMensaje(101); // SAT_GLOBAL_START
    }

    // 0:2:0|  -> parar global
    else if (codigo == 2) {
      enviarDatosDHT        = false;
      enviarDistancia       = false;
      enviarServoDatos      = false;
      servoMovimientoActivo = false;
      enviarCodigoMensaje(102); // SAT_GLOBAL_STOP
    }

    // 0:3:T|  -> periodo global
    else if (codigo == 3) {
      if (valor1 == 0) {
        periodoGlobalEnvio = 0;
        enviarCodigoMensaje(103); // SAT_GLOBAL_T_OFF
      } else if (valor1 >= 100 && valor1 <= 10000) {
        periodoGlobalEnvio = (unsigned long)valor1;

        // forzamos todos los periodos a ser el global
        periodoDHT        = periodoGlobalEnvio;
        periodoDistancia  = periodoGlobalEnvio;
        periodoServoDatos = periodoGlobalEnvio;

        enviarCodigoMensaje(104); // SAT_GLOBAL_T_SET
      } else {
        enviarCodigoMensaje(105); // SAT_GLOBAL_T_ERR
      }
    }
  }

  // ======================================================
  // Grupo 1: Sensor humedad / temperatura (1:...)
  // ======================================================
  else if (grupo == 1) {
    // 1:1|--> iniciar dht
    if (codigo == 1) {
      enviarDatosDHT = true;
      enviarCodigoMensaje(200); // DHT_ON
    }

    //1:2|  --> parar envío
    else if (codigo == 2) {
      enviarDatosDHT = false;
      digitalWrite(LED_PIN, LOW);
      enviarCodigoMensaje(201); // DHT_OFF
    }

    // 1:3:T|  --> cambiar periodo de envío solo DHT (ms)
    else if (codigo == 3) {
      if (valor1 >= 500 && valor1 <= 5000) {
        periodoDHT = (unsigned long)valor1;
        enviarCodigoMensaje(202); // DHT_T_SET
      } else {
        enviarCodigoMensaje(203); // DHT_T_ERR
      }
    }

    // 1:4:0|  --> media en Python (Tierra)
    else if (codigo == 4) {
      calcularMediaEnSatelite = false;
      enviarCodigoMensaje(204); // DHT_MEAN_PY
    }

    // 1:5:0|  --> media en Satélite
    else if (codigo == 5) {
      calcularMediaEnSatelite = true;
      enviarCodigoMensaje(205); // DHT_MEAN_SAT
    }
  }

  // ======================================================
  // Grupo 2: Servo (2:...)
  // ======================================================
  else if (grupo == 2) {
    // 2:1:A|  -> mover al ángulo deseado manualmente
    if (codigo == 1) {
      int nuevoAngulo = (int)valor1;  // ángulo en rango [-90,90] desde Tierra

      if (nuevoAngulo >= -90 && nuevoAngulo <= 90) {
        int nuevoAnguloServo = nuevoAngulo + 90;

        anguloObjetivo = nuevoAnguloServo;
        angulo         = anguloObjetivo;
        servoMotor.write(anguloObjetivo);

        modoManual   = true;
        inicioManual = ahora;

        // Confirmación numérica a Tierra: dato 6 = ángulo del servo
        enviarDatoByte(6, (int8_t)nuevoAnguloServo);

        enviarCodigoMensaje(300); // SERVO_SET_OK
      } else {
        enviarError(-6);  // error de ángulo/servo
        enviarCodigoMensaje(301); // SERVO_ANGLE_ERR
      }
    }

    // 2:2:0|  -> parar movimiento del servo (barrido automático)
    else if (codigo == 2) {
      servoMovimientoActivo = false;
      enviarCodigoMensaje(302); // SERVO_AUTO_OFF
    }

    // 2:3:0|  -> reanudar movimiento del servo
    else if (codigo == 3) {
      servoMovimientoActivo = true;
      enviarCodigoMensaje(303); // SERVO_AUTO_ON
    }

    // 2:4:T|  -> periodo envío ángulo (telemetría)
    else if (codigo == 4) {
      if (valor1 == 0) {
        enviarServoDatos = false;
        enviarCodigoMensaje(304); // SERVO_TLM_OFF
      } else if (valor1 >= 100 && valor1 <= 5000) {
        periodoServoDatos = (unsigned long)valor1;
        enviarServoDatos  = true;
        enviarCodigoMensaje(305); // SERVO_TLM_SET
      } else {
        enviarCodigoMensaje(306); // SERVO_TLM_ERR
      }
    }

    // 2:5:Tciclo|  -> tiempo (en ms) para recorrer 180º
    else if (codigo == 5) {
      Serial.print(F("Comando 2:5 recibido. valor1 = "));
      Serial.println(valor1);

      if (valor1 >= 200 && valor1 <= 20000) {
        tiempoCicloServo = (unsigned long)valor1;
        Serial.print(F("Nuevo tiempoCicloServo = "));
        Serial.println(tiempoCicloServo);
        enviarCodigoMensaje(307);
      } else {
        Serial.println(F("ERROR: tiempoCicloServo fuera de rango."));
        enviarCodigoMensaje(308);
      }
    }
  }

  // ======================================================
  // Grupo 3: Ultrasonidos (3:...)
  // ======================================================
  else if (grupo == 3) {
    // 3:1:0|  -> Start envío distancia
    if (codigo == 1) {
      enviarDistancia = true;
      enviarCodigoMensaje(400); // DIST_ON
    }

    // 3:2:0|  -> Stop distancia
    else if (codigo == 2) {
      enviarDistancia = false;
      enviarCodigoMensaje(401); // DIST_OFF
    }

    // 3:3:T|  -> Periodo distancia (ms)
    else if (codigo == 3) {
      if (valor1 >= 100 && valor1 <= 10000) {
        periodoDistancia = (unsigned long)valor1;
        enviarCodigoMensaje(402); // DIST_T_SET
      } else {
        enviarCodigoMensaje(403); // DIST_T_ERR
      }
    }
  }
}

void setup() {

  //pinMode(LED_PIN, OUTPUT);     // esta comentado porque si no el LED es un faro
  pinMode(LED_ERR_Dist, OUTPUT);
  pinMode(LED_E, OUTPUT);
  pinMode(LED_CHK_ERR_S, OUTPUT);
  digitalWrite(LED_CHK_ERR_S, LOW);
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  Serial.begin(9600);      // Radar / debug
  mySerial.begin(9600);    // Comunicación con Tierra

  Serial.setTimeout(50);
  mySerial.setTimeout(50);

  dht.begin();

  servoMotor.attach(SERVO_PIN);
  servoMotor.write(angulo);

  Serial.println(F("Satelite listo. Transmisión activa."));
  enviarCodigoMensaje(100);   // SAT_INIT
  tUltimoServo = millis();
}

void loop() {

  unsigned long ahora = millis();
  static unsigned long ultimoRx = 0;          // OJO

  // =========================
  // RECEPCIÓN DE FRAMES BINARIOS
  // =========================
  while (mySerial.available()) {
    uint8_t b = (uint8_t)mySerial.read();
    ultimoRx = ahora;

    switch (rxState) {
      case 0:  // esperando STX
        if (b == STX) {
          rxState = 1;
        }
        break;

      case 1:  // TYPE
        rxType = b;
        rxState = 2;
        break;

      case 2:  // LEN
        rxLen = b;
        if (rxLen > sizeof(rxBuf)) {
          // overflow => error
          digitalWrite(LED_CHK_ERR_S, HIGH);
          ultimoErrorChk = millis();
          rxState = 0;
        } else {
          rxIndex = 0;
          rxState = (rxLen == 0) ? 4 : 3;
        }
        break;

      case 3:  // PAYLOAD
        rxBuf[rxIndex++] = b;
        if (rxIndex >= rxLen) {
          rxState = 4;
        }
        break;
      
      
      case 4: { // CHECKSUM con comportamiento normal
        uint8_t csRecv = b;
        uint8_t csCalc = calcChecksum(rxType, rxLen, rxBuf);

        if (csRecv != csCalc) {
          // Checksum INCORRECTO
          digitalWrite(LED_CHK_ERR_S, HIGH);
          ultimoErrorChk = millis();
          enviarCodigoMensaje(190); // SAT_CHK_ERR
          Serial.println(F("DEBUG: checksum ERROR"));
        } else {
          // Checksum OK
          digitalWrite(LED_CHK_ERR_S, LOW);
          Serial.println(F("DEBUG: checksum OK"));

          if (rxType == TYPE_CMD) {
            // Ejecutar comando recibido desde Tierra
            procesarFrameComando(rxBuf, rxLen, ahora);
          }
        }

        rxState = 0;
        break;
      }


      /*
      case 4: { // DEBUG que siempre activa CHK_ERR_E
        uint8_t csRecv = b;
        uint8_t csCalc = calcChecksum(rxType, rxLen, rxBuf);

        // PRUEBA: fuerza SIEMPRE la rama de error
        digitalWrite(LED_CHK_ERR_S, HIGH);
        delay(200);
        ultimoErrorChk = millis();
        enviarCodigoMensaje(190); // SAT_CHK_ERR
        Serial.println(F("DEBUG: rama de checksum ERROR ejecutada"));
        rxState = 0;
        break;
      }
      */

    }
  }

  if (millis() - ultimoRx < 200) {
    digitalWrite(LED_E, HIGH);
  } else {
    digitalWrite(LED_E, LOW);
  }

  // === LECTURA Y ENVÍO DHT (protocolo DATOS id=2,3,4) ===
  if (enviarDatosDHT && (ahora - ultimoEnvioDHT >= periodoDHT)) {

    ultimoEnvioDHT = ahora;

    float h = dht.readHumidity();
    float t = dht.readTemperature();

    if (isnan(h) || isnan(t)) {
      //Error con la lectura del sensor de temperatura (-2) y humedad (-3)
      enviarError(-2);
      enviarError(-3);

    } else {

      if (calcularMediaEnSatelite) {
        bufferTemps[indiceTemp] = t;
        indiceTemp = (indiceTemp + 1) % 10;
        if (numTemp < 10) {
          numTemp++;
        }
        mediaTemp = calcularMedia();
      }

      digitalWrite(LED_PIN, HIGH);

      if (puedeEnviarGlobal()) {
        // humedad (id 2)
        enviarDatoFloat(2, h);

        // temperatura (id 3)
        enviarDatoFloat(3, t);

        // media temperatura (id 4)
        if (calcularMediaEnSatelite) {
          enviarDatoFloat(4, mediaTemp);
        }
      }
      digitalWrite(LED_PIN, LOW);
    }

    ultimoEnvioDHT = ahora;
  }

  // MEDICIÓN DE DISTANCIA (protocolo DATOS id=5 / error -5)
  if (enviarDistancia && (ahora - ultimoEnvioDist >= periodoDistancia)) {
    ultimoEnvioDist = ahora;
    float distancia = medirDistanciaMedia(NUM_MEDIDAS); // número de lecturas que hacen media

    if (distancia < 0.0f) {
      // error distancia -> -5
      enviarError(-5);
      digitalWrite(LED_ERR_Dist, HIGH);
    } 
    else {
      if (puedeEnviarGlobal()) {
        digitalWrite(LED_ERR_Dist, LOW);
        enviarDatoFloat(5, distancia);
        // Serial.print("Distancia: ");
        // Serial.println(distancia);       // DEBUG
      }
    }
  }

  /*
  // CONTROL MANUAL DE SERVO
  if (Serial.available() > 0) {
    int nuevoAngulo = Serial.parseInt();  // parseInt = leer un entero

    if (nuevoAngulo >= -90 && nuevoAngulo <= 90) {
      int nuevoAnguloServo = nuevoAngulo + 90;

      anguloObjetivo = nuevoAnguloServo;
      angulo = anguloObjetivo;
      servoMotor.write(anguloObjetivo);

      modoManual = true;
      inicioManual = millis();

      if (Serial.available() > 0) {
        Serial.read();
      }

      mySerial.print(F("Comando recibido. Angulo: "));
      mySerial.print(nuevoAngulo);
      mySerial.print(F(" --> "));
      mySerial.println(nuevoAnguloServo);
    }
  }
  */

  // MOVIMIENTO AUTOMÁTICO SERVO
  if ((unsigned long)(ahora - tUltimoServo) >= INTERVALO_SERVO) {
    // Calculamos cuánto tiempo real ha pasado desde el último paso
    unsigned long dt = ahora - tUltimoServo;   // ms
    tUltimoServo = ahora;

    if (modoManual) {
      unsigned long ahoraServo = millis();
      servoMotor.write(anguloObjetivo);

      if (ahoraServo - inicioManual >= TIEMPO_MANTENER_ANG) {
        modoManual = false;
      }
    }
    else if (servoMovimientoActivo) {
      // Velocidad en grados por milisegundo para recorrer 180º en tiempoCicloServo
      float velDegPorMs = 180.0f / (float)tiempoCicloServo;  // º/ms
      float delta = velDegPorMs * (float)dt;                 // grados a avanzar en este intervalo

      float nuevoAng = (float)angulo + (direccion * delta);

      if (nuevoAng >= 180.0f) {
        nuevoAng = 180.0f;
        direccion = -1;
      } else if (nuevoAng <= 0.0f) {
        nuevoAng = 0.0f;
        direccion = 1;
      }

      angulo = (int)(nuevoAng + 0.5f);  // redondeo al entero más cercano
      servoMotor.write(angulo);
      //Serial.println(angulo);
    }
  }

  // TELEMETRÍA PERIÓDICA DEL SERVO (id dato 6)
  if (enviarServoDatos && (ahora - ultimoEnvioServoDatos >= periodoServoDatos)) {
    ultimoEnvioServoDatos = ahora;

    if (puedeEnviarGlobal()){
      enviarDatoByte(6, (int8_t)angulo);   // ángulo actual 0–180
      //digitalWrite(LED_E, HIGH);
      // Serial.println(cuerpo);
    }
  }

  // Apagado del LED de error de checksum tras un tiempo
  if (digitalRead(LED_CHK_ERR_S) == HIGH) {
    if (millis() - ultimoErrorChk > DURACION_LED_CHK) {
      digitalWrite(LED_CHK_ERR_S, LOW);
    }
  }
}
